# RSA - 2

## Challenge

Hey I heard you have a supercomputer at home. This is taking too long to compute on my computer. Could you take a look on yours? I'm sure its a lot more precise than mine is, and faster too!

```text
e: 3
c: 2780321436921227845269766067805604547641764672251687438825498122989499386967784164108893743279610287605669769995594639683212592165536863280639528420328182048065518360606262307313806591343147104009274770408926901136562839153074067955850912830877064811031354484452546219065027914838811744269912371819665118277221
n: 23571113171923293137414347535961677173798389971011031071091131271311371391491511571631671731791811911931971992112232272292332392412512572632692712772812832933073113133173313373473493533593673733793833893974014094194214314334394434494574614634674794874914995035095215235415475575635695715775875935996016076136176196316416436476536596616736776836917017097197277337397437517577617697737877978098118218238278298398538578598638778818838879079119199299379419479539679719779839919971009101310191431936117404941729571877755575331917062752829306305198341421305376800954281557410379953262534149212590443063350628712530148541217933209759909975139820841212346188350112608680453894647472456216566674289561525527394398888860917887112180144144965154878409149321280697460295807024856510864232914981820173542223592901476958693572703687098161888680486757805443187028074386001621827485207065876653623459779938558845775617779542038109532989486603799040658192890612331485359615639748042902366550066934348195272617921683
```

# Solution

Lets take a look at the values we're given. N looks extremely big, and unfactorizable. It would take too long to factorize. This would make it difficult to crack the solution, but we see that the value of e is tiny. This might give us a hint on how to proceed.
<br>
RSA works on the principles of modulus and exponents. The forumla for converting a plaintext message into a cyphertext is

```python
cyphertext = (plaintext ** e) % n
```

Now, looking at e being tiny, it looks like it is possible that `plaintext ** e` could be smaller than the value of n. In that case, modulus n plays no part in the encryption formula. This changes the formula to

```python
cyphertext = (plaintext ** e)
```

Using this formula, we can obtain plaintext using cyphertext and e

```python
plaintext = (cyphertext ** (1/e))
```

Performing cube root on the cyphertext should then give you the plaintext. As python doesn't have the precition required to perform such a large cube root, I used [this website](https://www.dcode.fr/cube-root) to obtain cuberoot (it broke the css of the website but hey it worked)

Converting the obtained cuberoot `14061500589727237715723597570826081039597762758283503070252061800455951899778424597542833650554379318141` from decimal to hex, and then to ascii gives us the flag

### flag: dsc{t0-m355-w1th-m4th-t4k35-4-l0t-0f-sp1n3}
